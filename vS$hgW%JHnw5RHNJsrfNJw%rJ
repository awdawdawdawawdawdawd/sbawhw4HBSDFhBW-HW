-- Fuger Hub — Booga Booga Reborn (FULL, без Speed-Fly по твоему запросу)
-- UI: Fluent-Renewed  •  Автор: Fuger XD

-- ========= [ Fluent UI и менеджеры ] =========
local Library = loadstring(game:HttpGetAsync("https://github.com/1dontgiveaf/Fluent-Renewed/releases/download/v1.0/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/1dontgiveaf/Fluent-Renewed/refs/heads/main/Addons/SaveManager.luau"))()
local InterfaceManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/1dontgiveaf/Fluent-Renewed/refs/heads/main/Addons/InterfaceManager.luau"))()

-- ========= [ Services / utils ] =========
local HttpService       = game:GetService("HttpService")
local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService        = game:GetService("RunService")
local Workspace         = game:GetService("Workspace")
local UIS               = game:GetService("UserInputService")
local Lighting          = game:GetService("Lighting")

local plr  = Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local hum  = char:WaitForChild("Humanoid")
local root = char:WaitForChild("HumanoidRootPart")

local function ensureChar()
    char = plr.Character or plr.CharacterAdded:Wait()
    hum  = char:WaitForChild("Humanoid")
    root = char:WaitForChild("HumanoidRootPart")
end
plr.CharacterAdded:Connect(function() task.defer(ensureChar) end)

-- ==== Friend cache (Roblox friends) ====
local Friend = { set = {}, last = 0, ttl = 60 }

local function refreshFriends(force)
    if not force and (tick() - Friend.last) < Friend.ttl then return end
    Friend.last = tick()
    local ok, pages = pcall(function()
        return Players:GetFriendsAsync(plr.UserId)
    end)
    if not ok or not pages then return end
    local set = {}
    while true do
        for _, f in ipairs(pages:GetCurrentPage()) do
            set[f.Id] = true
        end
        if pages.IsFinished then break end
        pcall(function() pages:AdvanceToNextPageAsync() end)
    end
    Friend.set = set
end
refreshFriends(true)
task.spawn(function()
    while true do
        refreshFriends(false)
        task.wait(30)
    end
end)

local function isFriendPlayer(p)
    if not p or not p.UserId then return false end
    if Friend.set[p.UserId] then return true end
    local ok, v = pcall(function() return plr:IsFriendsWith(p.UserId) end)
    if ok and v then Friend.set[p.UserId] = true; return true end
    return false
end

local function isFriendByModelName(modelName)
    local p = Players:FindFirstChild(modelName)
    return isFriendPlayer(p)
end

-- ========= [ Packets (без ошибок, если модуля нет) ] =========
local packets do
    local ok, mod = pcall(function() return require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Packets")) end)
    packets = ok and mod or {}
end
local function swingtool(eids)
    if type(eids) ~= "table" then eids = { eids } end
    if packets and packets.SwingTool and packets.SwingTool.send then
        pcall(function() packets.SwingTool.send(eids) end)
    end
end
local function pickup(eid)
    if packets and packets.Pickup and packets.Pickup.send then
        pcall(function() packets.Pickup.send(eid) end)
    end
end

-- ========= [ Window / Tabs ] =========
local Window = Library:CreateWindow{
    Title = "Fuger Hub -- Booga Booga Reborn",
    SubTitle = "by Fuger XD",
    Size = UDim2.fromOffset(900, 600),
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
}
local Tabs = {}
Tabs.Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })

-- менеджеры
SaveManager:SetLibrary(Library)
InterfaceManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

-- ========= [ Helpers ] =========
local function sanitize(name)
    name = tostring(name or ""):gsub("[%c\\/:*?\"<>|]+",""):gsub("^%s+",""):gsub("%s+$","")
    return name == "" and "default" or name
end

-- ========= [ ROUTE persist ] =========
local function routePath(cfg) return "FluentScriptHub/specific-game/"..sanitize(cfg)..".route.json" end
local ROUTE_AUTOSAVE = "FluentScriptHub/specific-game/_route_autosave.json"

local function encodeRoute(points)
    local t = {}
    for i,p in ipairs(points or {}) do
        t[i] = { x=p.pos.X, y=p.pos.Y, z=p.pos.Z, wait=p.wait or 0, js=p.jump_start or nil, je=p.jump_end or nil }
    end
    return t
end
local function decodeRoute(t)
    local out = {}
    for _,r in ipairs(t or {}) do
        table.insert(out, { pos=Vector3.new(r.x,r.y,r.z), wait=(r.wait and r.wait>0) and r.wait or nil, jump_start=r.js or nil, jump_end=r.je or nil })
    end
    return out
end
local function Route_SaveToFile(path, points)
    if not writefile then return false end
    local ok, json = pcall(function() return HttpService:JSONEncode(encodeRoute(points)) end)
    if not ok then return false end
    local ok2 = pcall(writefile, path, json)
    return ok2 == true or ok2 == nil
end
local function Route_LoadFromFile(path, Route, redraw)
    if not (isfile and readfile) or not isfile(path) then return false end
    local ok, json = pcall(readfile, path); if not ok then return false end
    local ok2, arr = pcall(function() return HttpService:JSONDecode(json) end); if not ok2 then return false end
    table.clear(Route.points)
    if redraw and type(redraw.clearDots) == "function" then redraw.clearDots() end
    for _,p in ipairs(decodeRoute(arr)) do
        table.insert(Route.points, p)
        if redraw and type(redraw.dot) == "function" then redraw.dot(Color3.fromRGB(255,230,80), p.pos, 0.7) end
    end
    return true
end

-- ========= [ Общие инвентарь/еды ] =========
function findInventoryList()
    local pg = plr:FindFirstChild("PlayerGui"); if not pg then return nil end
    local mg = pg:FindFirstChild("MainGui");    if not mg then return nil end
    local rp = mg:FindFirstChild("RightPanel"); if not rp then return nil end
    local inv = rp:FindFirstChild("Inventory"); if not inv then return nil end
    return inv:FindFirstChild("List")
end
function getSlotByName(itemName)
    local list = findInventoryList()
    if not list then return nil end
    for _,child in ipairs(list:GetChildren()) do
        if child:IsA("ImageLabel") and child.Name == itemName then
            return child.LayoutOrder
        end
    end
    return nil
end
function consumeBySlot(slot)
    if not slot then return false end
    if packets and packets.UseBagItem     and packets.UseBagItem.send     then pcall(function() packets.UseBagItem.send(slot) end);     return true end
    if packets and packets.ConsumeBagItem and packets.ConsumeBagItem.send then pcall(function() packets.ConsumeBagItem.send(slot) end); return true end
    if packets and packets.ConsumeItem    and packets.ConsumeItem.send    then pcall(function() packets.ConsumeItem.send(slot) end);    return true end
    if packets and packets.UseItem        and packets.UseItem.send        then pcall(function() packets.UseItem.send(slot) end);        return true end
    return false
end
_G.fruittoitemid = _G.fruittoitemid or {
    Bloodfruit=94, Bluefruit=377, Lemon=99, Coconut=1, Jelly=604, Banana=606, Orange=602,
    Oddberry=32, Berry=35, Strangefruit=302, Strawberry=282, Sunfruit=128, Pumpkin=80,
    ["Prickly Pear"]=378, Apple=243, Barley=247, Cloudberry=101, Carrot=147
}
function getItemIdByName(name) local t=_G.fruittoitemid return t and t[name] or nil end
function consumeById(id)
    if not id then return false end
    if packets and packets.ConsumeItem and packets.ConsumeItem.send then pcall(function() packets.ConsumeItem.send(id) end); return true end
    if packets and packets.UseItem     and packets.UseItem.send     then pcall(function() packets.UseItem.send({itemID=id}) end); return true end
    if packets and packets.Eat         and packets.Eat.send         then pcall(function() packets.Eat.send(id) end); return true end
    if packets and packets.EatFood     and packets.EatFood.send     then pcall(function() packets.EatFood.send(id) end); return true end
    return false
end

-- ========= [ TAB: Configs ] =========
Tabs.Configs = Window:AddTab({ Title = "Configs", Icon = "save" })

-- общий парсер клавиш (если уже есть в коде — не переопределим)
if not _parseKeyName then
    function _parseKeyName(s)
        s = tostring(s or ""):gsub("%s+", "")
        return Enum.KeyCode[s] or Enum.KeyCode.Unknown
    end
end

-- === Runtime sync из UI после загрузки конфига ===
local function SyncRuntimeFromUI()
    -- FOLLOW: восстановить реальный KeyCode из инпута
    if follow_key_label then
        local ok, txt = pcall(function() return follow_key_label.Value end)
        if ok then
            local kc = _parseKeyName(txt)
            if kc ~= Enum.KeyCode.Unknown then
                _followKey = kc
            end
        end
    end
    -- GOD TRAP: если есть функция синка — вызовем
    if type(GT_SyncBindsFromUI) == "function" then
        pcall(GT_SyncBindsFromUI)
    end
end

local cfgName = "default"
local cfgInput = Tabs.Configs:AddInput("cfg_name_input",{ Title="Config name", Default=cfgName })
cfgInput:OnChanged(function(v) cfgName = sanitize(v) end)
Tabs.Configs:CreateButton({
    Title="Quick Save",
    Callback=function()
        local n = sanitize(cfgName)
        pcall(function() SaveManager:Save(n) end)
        Route_SaveToFile(routePath(n), (_G.__ROUTE and _G.__ROUTE.points) or {})
        Route_SaveToFile(ROUTE_AUTOSAVE, (_G.__ROUTE and _G.__ROUTE.points) or {})
        Library:Notify{ Title="Configs", Content="Saved "..n.." (+route)", Duration=3 }
    end
})
Tabs.Configs:CreateButton({
    Title="Quick Load",
    Callback=function()
        local n = sanitize(cfgName)
        pcall(function() SaveManager:Load(n) end)
        if _G.__ROUTE then
            local ok = Route_LoadFromFile(routePath(n), _G.__ROUTE, _G.__ROUTE._redraw)
            Library:Notify{ Title="Configs", Content="Loaded "..n..(ok and " +route" or " (no route file)"), Duration=3 }
        else
            Library:Notify{ Title="Configs", Content="Loaded "..n, Duration=3 }
        end
        SyncRuntimeFromUI() -- ← применяем реальные переменные из UI
    end
})
local auto = Tabs.Configs:CreateToggle("autoload_cfg",{ Title="Autoload this config", Default=true })
auto:OnChanged(function(v)
    local n = sanitize(cfgName)
    if v then pcall(function() SaveManager:SaveAutoloadConfig(n) end)
    else pcall(function() SaveManager:DeleteAutoloadConfig() end) end
end)

-- ========= [ TAB: Auto Loot ] =========
Tabs.Loot = Window:AddTab({ Title = "Auto Loot", Icon = "package" })
local LOOT_ITEM_NAMES = {
    "Berry","Bloodfruit","Bluefruit","Lemon","Strawberry","Gold","Raw Gold","Crystal Chunk",
    "Coin","Coins","Coin Stack","Essence","Emerald","Raw Emerald","Pink Diamond",
    "Raw Pink Diamond","Void Shard","Jelly","Magnetite","Raw Magnetite","Adurite","Raw Adurite",
    "Ice Cube","Stone","Iron","Raw Iron","Steel","Hide","Leaves","Log","Wood","Pie"
}
local loot_on        = Tabs.Loot:CreateToggle("loot_on",      { Title="Auto Loot", Default=false })
local loot_range     = Tabs.Loot:CreateSlider("loot_range",   { Title="Range (studs)", Min=5, Max=150, Rounding=0, Default=40 })
local loot_batch     = Tabs.Loot:CreateSlider("loot_batch",   { Title="Max pickups / tick", Min=1, Max=50, Rounding=0, Default=12 })
local loot_cd        = Tabs.Loot:CreateSlider("loot_cd",      { Title="Tick cooldown (s)", Min=0.03, Max=0.4, Rounding=2, Default=0.08 })
local loot_chests    = Tabs.Loot:CreateToggle("loot_chests",  { Title="Also loot chests (Contents)", Default=true })
local loot_blacklist = Tabs.Loot:CreateToggle("loot_black",   { Title="Use selection as Blacklist (else Whitelist)", Default=false })
local loot_debug     = Tabs.Loot:CreateToggle("loot_debug",   { Title="Debug (F9)", Default=false })
local loot_dropdown  = Tabs.Loot:CreateDropdown("loot_items", { Title="Items (multi)", Values = LOOT_ITEM_NAMES, Multi=true, Default = { Leaves = true, Log = true } })

local function safePickup2(eid)
    local ok = pcall(function() pickup(eid) end)
    if not ok and packets and packets.Pickup and packets.Pickup.send then
        pcall(function() packets.Pickup.send(eid) end)
    end
end
local DROP_FOLDERS = { "Items","Drops","WorldDrops","Loot","Dropped","Resources" }
local watchedFolders, conns = {}, {}
local cache = {}
local function normalizedName(inst)
    local a
    if inst.GetAttribute then
        a = inst:GetAttribute("ItemName") or inst:GetAttribute("Name") or inst:GetAttribute("DisplayName")
    end
    if typeof(a) == "string" and a ~= "" then return a end
    return inst.Name
end
local function addDrop(inst)
    if cache[inst] then return end
    local eid = inst.GetAttribute and inst:GetAttribute("EntityID")
    if not eid then return end
    local name = normalizedName(inst)
    local getPos
    if inst:IsA("Model") then
        local pp = inst.PrimaryPart or inst:FindFirstChildWhichIsA("BasePart"); if not pp then return end
        getPos = function() return pp.Position end
    elseif inst:IsA("BasePart") or inst:IsA("MeshPart") then
        getPos = function() return inst.Position end
    else
        return
    end
    cache[inst] = { eid = eid, name = name, getPos = getPos }
end
local function removeDrop(inst) cache[inst] = nil end
local function hookFolder(folder)
    if not folder or watchedFolders[folder] then return end
    watchedFolders[folder] = true
    for _,ch in ipairs(folder:GetChildren()) do addDrop(ch) end
    conns[#conns+1] = folder.ChildAdded:Connect(addDrop)
    conns[#conns+1] = folder.ChildRemoved:Connect(removeDrop)
end
local function hookChests()
    local dep = workspace:FindFirstChild("Deployables")
    if not dep then return end
    for _,mdl in ipairs(dep:GetChildren()) do
        if mdl:IsA("Model") then
            local contents = mdl:FindFirstChild("Contents")
            if contents and not watchedFolders[contents] then
                hookFolder(contents)
            end
        end
    end
    conns[#conns+1] = dep.ChildAdded:Connect(function(mdl)
        task.defer(function()
            if mdl:IsA("Model") then
                local contents = mdl:FindFirstChild("Contents")
                if contents then hookFolder(contents) end
            end
        end)
    end)
end
for _,n in ipairs(DROP_FOLDERS) do hookFolder(workspace:FindFirstChild(n)) end
hookChests()
task.spawn(function()
    while true do
        for _,n in ipairs(DROP_FOLDERS) do
            local f = workspace:FindFirstChild(n)
            if f and not watchedFolders[f] then hookFolder(f) end
        end
        if loot_chests.Value then hookChests() end
        task.wait(1.0)
    end
end)
local function selectedSet()
    local sel, val = {}, loot_dropdown.Value
    if typeof(val) == "table" then
        for k,v in pairs(val) do if v then sel[string.lower(k)] = true end end
    end
    return sel
end
task.spawn(function()
    while true do
        if loot_on.Value and root then
            local set       = selectedSet()
            local useBlack  = loot_blacklist.Value
            local range     = loot_range.Value
            local maxPer    = math.max(1, math.floor(loot_batch.Value))
            local candidates = {}
            for inst,info in pairs(cache) do
                if inst.Parent then
                    local isContents = false
                    if not loot_chests.Value then
                        local p = inst.Parent
                        while p and p ~= workspace do
                            if p.Name == "Contents" then isContents = true; break end
                            p = p.Parent
                        end
                    end
                    if not isContents then
                        local pos = info.getPos()
                        local d   = (pos - root.Position).Magnitude
                        if d <= range then
                            local nm   = info.name or "Unknown"
                            local pass = true
                            if next(set) ~= nil then
                                local inSel = set[string.lower(nm)] == true
                                pass = (useBlack and (not inSel)) or ((not useBlack) and inSel)
                            end
                            if pass then candidates[#candidates+1] = { eid = info.eid, dist = d, name = nm } end
                        end
                    end
                end
            end
            if #candidates > 1 then table.sort(candidates, function(a,b) return a.dist < b.dist end) end
            if loot_debug.Value then
                print(("[AutoLoot] candidates=%d (mode=%s, chests=%s)")
                    :format(#candidates, useBlack and "Blacklist" or "Whitelist", tostring(loot_chests.Value)))
            end
            for i = 1, math.min(maxPer, #candidates) do
                safePickup2(candidates[i].eid)
                if loot_debug.Value then
                    print(("[AutoLoot] pickup #%d: %s [%.1f]"):format(i, candidates[i].name, candidates[i].dist))
                end
                task.wait(0.01)
            end
            task.wait(loot_cd.Value)
        else
            task.wait(0.15)
        end
    end
end)

-- ========= [ TAB: ESP — God Set ] =========
Tabs.ESP = Window:AddTab({ Title = "ESP (God Set)", Icon = "eye" })
local esp_enable      = Tabs.ESP:CreateToggle("god_esp_enable",    { Title = "Enable ESP", Default = true })
local esp_maxdist     = Tabs.ESP:CreateSlider("god_esp_maxdist",    { Title = "Max distance (studs)", Min=100, Max=3000, Rounding=0, Default=1200 })
local esp_showlabel   = Tabs.ESP:CreateToggle("god_esp_showlabel",  { Title = "Show label over head", Default = true })
local esp_highlight   = Tabs.ESP:CreateToggle("god_esp_highlight",  { Title = "Highlight only if Full Set (3/3)", Default = true })
local esp_only_full   = Tabs.ESP:CreateToggle("god_esp_onlyfull",   { Title = "Show ONLY players with Full Set (3/3)", Default = false })

local COLOR_OK  = Color3.fromRGB(90,255,120)
local COLOR_LO  = Color3.fromRGB(255,210,80)
local COLOR_NO  = Color3.fromRGB(255,90,90)

local GOD_MATCH = { halo={"God Halo","Halo"}, chest={"God Chestplate","Chestplate","God Armor","Armor"}, legs={"God Legs","Legs","Greaves"} }
local function nameMatch(n, list) n=string.lower(tostring(n or "")); for _,v in ipairs(list) do if n:find(string.lower(v),1,true) then return true end end end
local function countGodPieces(model)
    local bits = {halo=false, chest=false, legs=false}
    for _,d in ipairs(model:GetDescendants()) do
        local nm=d.Name
        if not bits.halo  and nameMatch(nm, GOD_MATCH.halo)  then bits.halo  = true end
        if not bits.chest and nameMatch(nm, GOD_MATCH.chest) then bits.chest = true end
        if not bits.legs  and nameMatch(nm, GOD_MATCH.legs)  then bits.legs  = true end
    end
    return (bits.halo and 1 or 0) + (bits.chest and 1 or 0) + (bits.legs and 1 or 0)
end
local function getCharModel(p) local wf=workspace:FindFirstChild("Players"); if wf then local m=wf:FindFirstChild(p.Name); if m and m:IsA("Model") then return m end end return p.Character end
local GOD_ESP = { map = {}, loop = nil, addConn=nil, remConn=nil }
local function makeBoard(adornee) local bb=Instance.new("BillboardGui"); bb.Name="_ESP_GODSET_BB"; bb.AlwaysOnTop=true; bb.Size=UDim2.fromOffset(150,22); bb.StudsOffsetWorldSpace=Vector3.new(0,3.6,0); bb.Adornee=adornee; bb.Parent=adornee; local tl=Instance.new("TextLabel"); tl.BackgroundTransparency=1; tl.Size=UDim2.fromScale(1,1); tl.Font=Enum.Font.GothamBold; tl.TextScaled=true; tl.TextStrokeTransparency=0.25; tl.Text="God Set 0/3"; tl.Parent=bb; return bb,tl end
local function ensureHL(model) local hl=model:FindFirstChild("_ESP_GODSET_HL"); if not hl then hl=Instance.new("Highlight"); hl.Name="_ESP_GODSET_HL"; hl.DepthMode=Enum.HighlightDepthMode.AlwaysOnTop; hl.FillTransparency=1; hl.OutlineTransparency=0; hl.Adornee=model; hl.Parent=model end return hl end
local function attachPlayer(p) if p==Players.LocalPlayer then return end local m=getCharModel(p); if not (m and m.Parent) then return end local hrp=m:FindFirstChild("HumanoidRootPart") or m:FindFirstChildWhichIsA("BasePart"); if not hrp then return end local bb,tl=makeBoard(hrp); local hl=ensureHL(m); GOD_ESP.map[p]={model=m, root=hrp, bb=bb, tl=tl, hl=hl} end
local function detachPlayer(p) local rec=GOD_ESP.map[p]; if not rec then return end if rec.bb then pcall(function() rec.bb:Destroy() end) end if rec.hl then pcall(function() rec.hl:Destroy() end) end GOD_ESP.map[p]=nil end
local function startGodESP()
    if GOD_ESP.loop then return end
    for _,p in ipairs(Players:GetPlayers()) do if p ~= Players.LocalPlayer then attachPlayer(p) end end
    GOD_ESP.addConn = Players.PlayerAdded:Connect(function(p) task.defer(function() attachPlayer(p) end) end)
    GOD_ESP.remConn = Players.PlayerRemoving:Connect(detachPlayer)
    GOD_ESP.loop = RunService.Heartbeat:Connect(function()
        if not esp_enable.Value then for _,rec in pairs(GOD_ESP.map) do if rec.bb then rec.bb.Enabled=false end if rec.hl then rec.hl.Enabled=false end end return end
        local myRoot = (plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")) or nil
        for p,rec in pairs(GOD_ESP.map) do
            if not (rec.model and rec.model.Parent and rec.root and rec.root.Parent) then detachPlayer(p); attachPlayer(p); rec=GOD_ESP.map[p] end
            if rec then
                local inDist = true
                if myRoot then inDist = ((rec.root.Position - myRoot.Position).Magnitude <= esp_maxdist.Value) end
                local cnt = countGodPieces(rec.model)
                local col = (cnt>=3 and COLOR_OK) or (cnt>=1 and COLOR_LO) or COLOR_NO
                local visibleByFilter = (not esp_only_full.Value) or (cnt>=3)
                if rec.tl then rec.tl.Text = string.format("God Set %d/3", cnt); rec.tl.TextColor3=col end
                if rec.bb then rec.bb.Enabled = esp_showlabel.Value and inDist and visibleByFilter end
                if rec.hl then rec.hl.OutlineColor=col; rec.hl.Enabled = (cnt>=3 and esp_highlight.Value and inDist) end
            end
        end
    end)
end
local function stopGodESP() if GOD_ESP.loop then GOD_ESP.loop:Disconnect() GOD_ESP.loop=nil end if GOD_ESP.addConn then GOD_ESP.addConn:Disconnect() GOD_ESP.addConn=nil end if GOD_ESP.remConn then GOD_ESP.remConn:Disconnect() GOD_ESP.remConn=nil end for p,_ in pairs(GOD_ESP.map) do detachPlayer(p) end end
esp_enable:OnChanged(function(v) if v then startGodESP() else stopGodESP() end end)
if esp_enable.Value then startGodESP() end

-- ===================== TAB: Combat (KillAura x2 burst + Follow + God-set filter + Friends skip) =====================
local Players2           = game:GetService("Players")
local RunService2        = game:GetService("RunService")
local ReplicatedStorage2 = game:GetService("ReplicatedStorage")
local UIS2               = game:GetService("UserInputService")
local LP                 = Players2.LocalPlayer

-- packets (safe reuse)
local packets2 = rawget(getfenv(), "packets") or (function()
    local ok, m = pcall(function()
        return require(ReplicatedStorage2:WaitForChild("Modules"):WaitForChild("Packets"))
    end)
    return ok and m or {}
end)()

-- helpers
local function myChar2() return LP.Character or LP.CharacterAdded:Wait() end
local function myHum2()  local ch=myChar2(); return ch:FindFirstChildOfClass("Humanoid") or ch:WaitForChild("Humanoid") end
local function myRoot2() local ch=LP.Character; return ch and ch:FindFirstChild("HumanoidRootPart") or nil end
local function ppOf(m)  return (m and m.PrimaryPart) or (m and m:FindFirstChild("HumanoidRootPart")) or (m and m:FindFirstChildWhichIsA("BasePart")) end
local function eidOfModel(m)
    if not m then return nil end
    if m.GetAttribute then local id=m:GetAttribute("EntityID"); if id then return id end end
    local p=m.Parent
    for _=1,4 do if not p then break end; if p.GetAttribute then local id=p:GetAttribute("EntityID"); if id then return id end end; p=p.Parent end
    return nil
end
local function isFriendByModelName2(name)
    local p = Players2:FindFirstChild(name)
    if not p then return false end
    local ok, val = pcall(function() return LP:IsFriendsWith(p.UserId) end)
    return ok and val or false
end

-- TAB
Tabs = Tabs or {}
Tabs.Combat = Tabs.Combat or Window:AddTab({ Title = "Combat", Icon = "axe" })

-- ==== Kill Aura (с burst x2, анимацию НЕ трогаем) ====
local ka_on       = Tabs.Combat:CreateToggle("ka_on",       { Title="Kill Aura", Default=false })
local ka_range    = Tabs.Combat:CreateSlider ("ka_range",   { Title="Range (studs)", Min=4,  Max=40,  Rounding=0, Default=14 })
local ka_targets  = Tabs.Combat:CreateSlider ("ka_targets", { Title="Max targets",   Min=1,  Max=8,   Rounding=0, Default=3 })
local ka_tick     = Tabs.Combat:CreateSlider ("ka_tick",    { Title="Tick (s)",      Min=0.03, Max=0.30, Rounding=3, Default=0.08 })

local ka_anim_on  = Tabs.Combat:CreateToggle("ka_anim_on",  { Title="Swing animation", Default=true })
local ka_anim_spd = Tabs.Combat:CreateSlider ("ka_anim_spd",{ Title="Anim speed",      Min=0.4, Max=2.2, Rounding=2, Default=1.15 })
local ka_blend_in = Tabs.Combat:CreateSlider ("ka_blend_in",{ Title="Blend-in (s)",    Min=0.00, Max=0.25, Rounding=2, Default=0.10 })
local ka_min_gap  = Tabs.Combat:CreateSlider ("ka_min_gap", { Title="Min gap between swings (s)", Min=0.10, Max=1.00, Rounding=2, Default=0.10 })
local ka_only_god = Tabs.Combat:CreateToggle("ka_only_god", { Title="Only with God Rock (ID 368)", Default=true })
local ka_skip_friends = Tabs.Combat:CreateToggle("ka_skip_friends", { Title = "KA: Skip Roblox friends", Default = true })

-- НОВОЕ: burst-удары (x2 по твоей просьбе, по умолчанию 2)
local ka_burst_count = Tabs.Combat:CreateSlider("ka_burst_count", { Title="Burst hits per tick", Min=1, Max=3, Rounding=0, Default=2 })
local ka_burst_gap   = Tabs.Combat:CreateSlider("ka_burst_gap",   { Title="Burst gap (s)", Min=0.00, Max=0.05, Rounding=3, Default=0.010 })

local SLASH_ID, GOD_ROCK_ID = 10761451679, 368
local function readIdFrom(inst)
    if not inst then return nil end
    if inst.GetAttribute then
        for _,k in ipairs({"ItemID","itemID","Id","id"}) do local v=inst:GetAttribute(k); local n=tonumber(v); if n then return n end end
    end
    if inst:IsA("NumberValue") or inst:IsA("IntValue") then return tonumber(inst.Value)
    elseif inst:IsA("StringValue") then return tonumber(inst.Value) end
end
local function currentWeapon()
    local ch=LP.Character; if not ch then return nil,nil end
    for _,t in ipairs(ch:GetChildren()) do
        if t:IsA("Tool") then
            local id=readIdFrom(t); if not id then for _,d in ipairs(t:GetDescendants()) do id=readIdFrom(d); if id then break end end end
            return t,id
        end
    end
    for _,d in ipairs(ch:GetDescendants()) do
        local id=readIdFrom(d); if id then return d,id end
        local n=(d.Name or ""):lower(); if n:find("god",1,true) and n:find("rock",1,true) then return d,GOD_ROCK_ID end
    end
    return nil,nil
end
local function isGodRockEquipped()
    local inst,id=currentWeapon()
    if id==GOD_ROCK_ID then return true,inst end
    if inst and inst.Name then local n=inst.Name:lower(); if n:find("god",1,true) and n:find("rock",1,true) then return true,inst end end
    return false,inst
end
local animator, slashTrack; local animAllow,swingBusy,queued=true,false,false; local nextAllowedAt,animLenGuess=0,0.60
local function refreshAnimator() local hum=myHum2(); animator=hum:FindFirstChildOfClass("Animator") or Instance.new("Animator",hum); slashTrack=nil end
local function ensureSlashTrack(id)
    if not animator then refreshAnimator() end
    if animator and not slashTrack then
        local a=Instance.new("Animation"); a.AnimationId="rbxassetid://"..tostring(id or SLASH_ID)
        local ok; ok,slashTrack=pcall(function() return animator:LoadAnimation(a) end); if not ok then slashTrack=nil return end
        slashTrack.Priority=Enum.AnimationPriority.Action; slashTrack.Looped=false
    end
end
local function stopSlashSafe(fade) if slashTrack then pcall(function() slashTrack:Stop(fade or 0) end) end swingBusy=false queued=false end
local function playSlashOnce()
    if not ka_anim_on.Value or not animAllow then return end
    if ka_only_god.Value and not isGodRockEquipped() then stopSlashSafe(0) nextAllowedAt=tick() return end
    ensureSlashTrack(SLASH_ID); if not slashTrack then return end
    local now=tick(); if now<nextAllowedAt or swingBusy then queued=true return end
    swingBusy=true queued=false
    pcall(function() slashTrack:Play(ka_blend_in.Value,1,ka_anim_spd.Value) end)
    task.defer(function() if slashTrack then local len=tonumber(slashTrack.Length); if len and len>0.01 then animLenGuess=len/math.max(ka_anim_spd.Value,0.01) end end end)
    nextAllowedAt = now + math.max(ka_min_gap.Value, animLenGuess*0.70)
    slashTrack.Stopped:Once(function()
        swingBusy=false
        if queued and animAllow and ka_anim_on.Value then
            queued=false
            local t=tick(); if t<nextAllowedAt then task.delay(nextAllowedAt-t,playSlashOnce) else playSlashOnce() end
        end
    end)
end
LP.CharacterAdded:Connect(function() task.defer(function() animAllow=false; stopSlashSafe(0); refreshAnimator(); task.wait(0.05); animAllow=true end) end)

local function collectTargets(range,k)
    local r=myRoot2(); if not r then return {} end
    local out={} local pf=workspace:FindFirstChild("Players")
    if pf then
        for _,m in ipairs(pf:GetChildren()) do
            if m.Name~=LP.Name then
                if ka_skip_friends.Value and isFriendByModelName2(m.Name) then
                else
                    local pp=ppOf(m)
                    if pp then local d=(pp.Position-r.Position).Magnitude
                        if d<=range then local id=eidOfModel(m); if id then out[#out+1]={id=id,d=d} end end
                    end
                end
            end
        end
    end
    table.sort(out,function(a,b) return a.d<b.d end)
    local t={} for i=1,math.min(k,#out) do t[#t+1]=out[i].id end
    return t
end

-- НОВОЕ: отправка burst (x2/x3) без изменения анимации (анимация проигрывается один раз на первый удар)
local function sendSwingBurst(ids)
    if #ids==0 then return end
    local n   = math.max(1, math.floor(ka_burst_count.Value))
    local gap = math.max(0, tonumber(ka_burst_gap.Value) or 0)

    for i=1,n do
        if packets2.SwingTool and packets2.SwingTool.send then
            pcall(function() packets2.SwingTool.send(ids) end)
        end
        if i==1 then playSlashOnce() end
        if i < n and gap > 0 then task.wait(gap) end
    end
end

local kaConn
local function startKA()
    if kaConn then return end
    kaConn=RunService2.Heartbeat:Connect(function()
        if not ka_on.Value then return end
        if ka_only_god.Value and not isGodRockEquipped() then
            stopSlashSafe(0); nextAllowedAt=tick(); task.wait(ka_tick.Value); return
        end
        local ids=collectTargets(ka_range.Value, math.max(1, math.floor(ka_targets.Value)))
        if #ids>0 then sendSwingBurst(ids) end
        task.wait(ka_tick.Value)
    end)
end
local function stopKA() if kaConn then kaConn:Disconnect() kaConn=nil end end
ka_on:OnChanged(function(v) if v then startKA() else stopKA() end end)
ka_anim_on:OnChanged(function(v) animAllow=v; if not v then stopSlashSafe(0.06) end end)
ka_anim_spd:OnChanged(function(v) if slashTrack and slashTrack.IsPlaying then pcall(function() slashTrack:AdjustSpeed(v) end) end end)
if ka_on.Value then startKA() end

-- ==== Follow (с пропуском друзей и фильтром God-set) ====
local follow_on        = Tabs.Combat:CreateToggle("follow_on",       { Title = "Follow nearest player", Default = false })
local follow_range     = Tabs.Combat:CreateSlider ("follow_range",   { Title = "Search range (studs)",  Min=10, Max=400, Rounding=0, Default=120 })
local follow_speed     = Tabs.Combat:CreateSlider ("follow_speed",   { Title = "Follow speed (stud/s)", Min=6,  Max=28,  Rounding=1, Default=16 })
local follow_stopdist  = Tabs.Combat:CreateSlider ("follow_stopdist",{ Title = "Stop distance (studs)", Min=0.0,  Max=18,  Rounding=1, Default=1.0 })
local follow_cd        = Tabs.Combat:CreateSlider ("follow_cd",      { Title = "Retarget every (s)",    Min=0.05, Max=1.00, Rounding=2, Default=0.18 })
local follow_face      = Tabs.Combat:CreateToggle("follow_face",     { Title = "Face the target while following", Default = true })
local follow_skip_friends = Tabs.Combat:CreateToggle("follow_skip_friends", { Title = "Follow: Skip Roblox friends", Default = true })

local follow_only_full   = Tabs.Combat:CreateToggle("follow_only_full",  { Title = "Follow only FULL God set (3/3)", Default = true })
local follow_prefer_full = Tabs.Combat:CreateToggle("follow_prefer_full",{ Title = "Prefer FULL God set (if available)", Default = true })

local GOD_MATCH2 = { halo={"God Halo","Halo"}, chest={"God Chestplate","Chestplate","God Armor","Armor"}, legs={"God Legs","Legs","Greaves"} }
local function _hit(nm, list) nm=string.lower(tostring(nm or "")); for _,v in ipairs(list) do if nm:find(string.lower(v),1,true) then return true end end end
local function countGodPiecesSafe(model)
    if type(countGodPieces)=="function" then local ok,n=pcall(function() return countGodPieces(model) end); if ok and type(n)=="number" then return n end end
    local b={halo=false,chest=false,legs=false}
    for _,d in ipairs(model:GetDescendants()) do local n=d.Name
        if not b.halo  and _hit(n,GOD_MATCH2.halo)  then b.halo=true end
        if not b.chest and _hit(n,GOD_MATCH2.chest) then b.chest=true end
        if not b.legs  and _hit(n,GOD_MATCH2.legs)  then b.legs=true end
    end
    return (b.halo and 1 or 0)+(b.chest and 1 or 0)+(b.legs and 1 or 0)
end

-- Follow BV
local F={bv=nil,rp=nil}
local function _clearFollowBV(rp) for _,o in ipairs(rp:GetChildren()) do if o:IsA("BodyVelocity") and o.Name=="_KA_FOLLOW_BV" then o:Destroy() end end end
local function ensureFollowBV()
    local ch=LP.Character; if not ch then return nil,nil end
    local rp=ch:FindFirstChild("HumanoidRootPart"); if not rp then return nil,nil end
    if (not F.bv) or (not F.bv.Parent) or (F.rp~=rp) then
        if F.bv then F.bv:Destroy() end
        _clearFollowBV(rp)
        local bv=Instance.new("BodyVelocity")
        bv.Name="_KA_FOLLOW_BV"; bv.MaxForce=Vector3.new(1e9,0,1e9); bv.Velocity=Vector3.new(); bv.Parent=rp
        F.bv,F.rp=bv,rp
    end
    return F.bv,rp
end
local function stopFollow() if F.bv then F.bv.Velocity=Vector3.new() end end
local function purgeFollowBV() local rp=myRoot2(); if rp then _clearFollowBV(rp) end F.bv,F.rp=nil,nil end
LP.CharacterAdded:Connect(function() task.defer(purgeFollowBV) end)

-- выбор цели
local function nearestPlayerWithin(rng)
    local r=myRoot2(); if not r then return nil,nil end
    local pf=workspace:FindFirstChild("Players"); if not pf then return nil,nil end
    local best_any,bestD_any,best_full,bestD_full
    for _,m in ipairs(pf:GetChildren()) do
        if m:IsA("Model") and m.Name~=LP.Name then
            if not ((follow_skip_friends.Value or ka_skip_friends.Value) and isFriendByModelName2(m.Name)) then
                local pp=ppOf(m)
                if pp then
                    local d=(pp.Position-r.Position).Magnitude
                    if d<=rng then
                        local pieces=countGodPiecesSafe(m)
                        if pieces>=3 then if (not bestD_full) or d<bestD_full then best_full,bestD_full=pp,d end end
                        if (not bestD_any) or d<bestD_any then best_any,bestD_any=pp,d end
                    end
                end
            end
        end
    end
    if follow_only_full.Value then return best_full,bestD_full end
    if follow_prefer_full.Value and best_full then return best_full,bestD_full end
    return best_any,bestD_any
end

-- follow loop
local followConn,lastPickAt,curTarget
local function startFollow()
    if followConn then return end
    followConn=RunService2.Heartbeat:Connect(function(dt)
        if not follow_on.Value then stopFollow() return end
        local now=tick()
        if (not curTarget) or (not curTarget.Parent) or (now-(lastPickAt or 0) >= follow_cd.Value) then
            curTarget=select(1, nearestPlayerWithin(follow_range.Value)); lastPickAt=now
        end
        if not (curTarget and curTarget.Parent) then stopFollow() return end
        local bv,rp=ensureFollowBV(); if not (bv and rp) then return end
        local me=rp.Position; local tgt=curTarget.Position
        local to2=Vector3.new(tgt.X-me.X,0,tgt.Z-me.Z)
        local dist=to2.Magnitude
        local stopAt = math.max(0.0, follow_stopdist.Value)
        if dist<=stopAt then
            bv.Velocity = Vector3.new()
        else
            bv.Velocity = to2.Unit * follow_speed.Value
            if follow_face.Value then
                local look=CFrame.lookAt(me, Vector3.new(tgt.X,me.Y,tgt.Z))
                rp.CFrame = rp.CFrame:Lerp(look, math.clamp(dt*6,0,1))
            end
        end
    end)
end
local function stopFollowAll() if followConn then followConn:Disconnect() followConn=nil end stopFollow() curTarget=nil purgeFollowBV() end
follow_on:OnChanged(function(v) if v then startFollow() else stopFollowAll() end end)
if follow_on.Value then startFollow() end

-- Follow keybind (с фиксом сохранения/загрузки)
local follow_bind_enable = Tabs.Combat:CreateToggle("follow_bind_enable", { Title="Enable follow keybind", Default=true })
local follow_bind_cd     = Tabs.Combat:CreateSlider("follow_bind_cd", { Title="Keybind cooldown (s)", Min=0.05, Max=1.00, Rounding=2, Default=0.20 })
local _followKey=Enum.KeyCode.N; local _awaitRebind=false; local _lastToggleAt=0
local follow_key_label = Tabs.Combat:AddInput("follow_key_label", { Title="Follow key", Default=_followKey.Name, Numeric=false, Finished=false })

follow_key_label:OnChanged(function(v)
    local kc = _parseKeyName and _parseKeyName(v) or Enum.KeyCode[v]
    if kc and kc ~= Enum.KeyCode.Unknown then
        _followKey = kc
    end
end)

Tabs.Combat:CreateButton({ Title="Rebind Follow (click, then press key)", Callback=function()
    _awaitRebind=true; Library:Notify({ Title="Follow", Content="Press a key (Esc = cancel)", Duration=3 })
end })
UIS2.InputBegan:Connect(function(input,gp)
    if gp or input.UserInputType~=Enum.UserInputType.Keyboard then return end
    if _awaitRebind then
        if input.KeyCode==Enum.KeyCode.Escape then _awaitRebind=false Library:Notify({Title="Follow",Content="Rebind canceled",Duration=1.3}) return end
        if input.KeyCode~=Enum.KeyCode.Unknown then _followKey=input.KeyCode; pcall(function() follow_key_label:SetValue(_followKey.Name) end); _awaitRebind=false; Library:Notify({Title="Follow",Content=("Bound to %s"):format(_followKey.Name),Duration=1.5}) end
        return
    end
    if follow_bind_enable.Value and input.KeyCode==_followKey then
        local now=tick()
        if now-_lastToggleAt >= (follow_bind_cd.Value or 0.2) then
            _lastToggleAt=now
            local newv=not follow_on.Value
            follow_on:SetValue(newv)
            if not newv then stopFollowAll() end
            Library:Notify({Title="Follow",Content=newv and "ON" or "OFF",Duration=1.2})
        end
    end
end)
-- ===================== /TAB: Combat =====================

-- ========= [ TAB: Heal — one full heal cycle then pause | AGGRESSIVE MODE ] =========
local HealTab = Window:AddTab({ Title = "Heal", Icon = "heart" })

local heal_toggle = HealTab:CreateToggle("heal_auto", { Title = "Auto Heal", Default = false })
local heal_item   = HealTab:CreateDropdown("heal_item", {
    Title  = "Item to use",
    Values = { "Bloodfruit","Bluefruit","Berry","Strawberry","Coconut","Apple","Lemon","Orange","Banana" },
    Default = "Bloodfruit"
})

local heal_min = HealTab:CreateSlider("heal_min", { Title = "Heal when HP below (%)", Min = 1, Max = 99, Rounding = 0, Default = 70 })
local heal_max = HealTab:CreateSlider("heal_max", { Title = "Stop when HP reaches (%)", Min = 2, Max = 100, Rounding = 0, Default = 90 })

local heal_hb   = HealTab:CreateToggle("heal_hb", { Title = "Use Heartbeat pacing", Default = true })
local heal_cd   = HealTab:CreateSlider("heal_cd", { Title = "Per-bite delay (s)", Min = 0.00, Max = 0.30, Rounding = 2, Default = 0.02 })
local heal_tick = HealTab:CreateSlider("heal_tick",{ Title = "Check interval (s) [timer mode]", Min = 0.00, Max = 0.20, Rounding = 2, Default = 0.01 })

local heal_cycle_pause = HealTab:CreateSlider("heal_cycle_pause", {
    Title = "Pause after full heal cycle (s)",
    Min = 0.50, Max = 10.00, Rounding = 2, Default = 3.00
})

local heal_overdrive = HealTab:CreateToggle("heal_overdrive", { Title = "Overdrive (aggressive bursts)", Default = true })
local heal_burst     = HealTab:CreateSlider ("heal_burst",     { Title = "Bites per burst", Min = 1, Max = 8, Rounding = 0, Default = 3 })
local heal_yield_n   = HealTab:CreateSlider ("heal_yield_n",   { Title = "Yield every N bites (avoid lag)", Min = 1, Max = 20, Rounding = 0, Default = 6 })

local heal_debug = HealTab:CreateToggle("heal_debug", { Title = "Debug logs (F9)", Default = false })

local function readHPpct()
    if hum == nil or hum.MaxHealth == 0 then return 100 end
    local v = (hum.Health / hum.MaxHealth) * 100
    return math.clamp(v, 0, 100)
end

local function clampBand()
    if heal_min.Value >= heal_max.Value then
        if heal_max.Value < 100 then heal_min:SetValue(heal_max.Value - 1) else heal_min:SetValue(99) end
    end
end
heal_min:OnChanged(clampBand)
heal_max:OnChanged(clampBand)

local function nowsec()
    return (typeof(time)=="function" and time()) or os.clock()
end

local function biteOnce(it)
    local slot = getSlotByName(it)
    return (slot ~= nil and consumeBySlot(slot)) or consumeById(getItemIdByName(it))
end

local lastCycleAt = 0
local healBusy    = false

local function runHealCycle()
    healBusy = true
    local it = heal_item.Value or "Bloodfruit"
    local target = math.clamp(heal_max.Value, heal_min.Value + 1, 100)
    local maxBites = 120
    local totalBites = 0

    if heal_debug.Value then
        print(string.format("[AutoHeal] start cycle: hp=%.1f -> target=%.1f (pause %.2fs, overdrive=%s, burst=%d)",
            readHPpct(), target, (heal_cycle_pause.Value or 3), tostring(heal_overdrive.Value), heal_burst.Value))
    end

    while readHPpct() < target and maxBites > 0 do
        local burst = (heal_overdrive.Value and math.max(1, math.floor(heal_burst.Value))) or 1

        for j = 1, burst do
            if readHPpct() >= target or maxBites <= 0 then break end
            local used = biteOnce(it)
            totalBites += 1
            maxBites   -= 1
            if heal_debug.Value then print("[AutoHeal] bite ->", used) end

            if heal_overdrive.Value then
                local n = math.max(1, math.floor(heal_yield_n.Value))
                if (totalBites % n) == 0 then task.wait() end
            end
        end

        if not heal_overdrive.Value then
            local d = heal_cd.Value; if d < 0 then d = 0 end
            if d > 0 then task.wait(d) else task.wait() end
        else
            local d = heal_cd.Value; if d < 0 then d = 0 end
            if d > 0 then task.wait(d) end
        end
    end

    lastCycleAt = nowsec()
    healBusy = false
    if heal_debug.Value then
        print(string.format("[AutoHeal] cycle done (bites=%d); pause until %.2f", totalBites, lastCycleAt + (heal_cycle_pause.Value or 3)))
    end
end

local hbConn
local function stopHB() if hbConn then hbConn:Disconnect(); hbConn = nil end end

local function startHB()
    stopHB()
    hbConn = RunService.Heartbeat:Connect(function()
        if not heal_toggle.Value or not hum or not hum.Parent then return end

        local hp = readHPpct()
        local pause = heal_cycle_pause.Value or 3
        local canStart = (nowsec() - lastCycleAt) >= pause

        if hp < heal_min.Value and (not healBusy) and canStart then
            task.spawn(runHealCycle)
        end
    end)
end

task.spawn(function()
    while true do
        if heal_toggle.Value and hum and hum.Parent and not heal_hb.Value then
            local hp = readHPpct()
            local pause = heal_cycle_pause.Value or 3
            local canStart = (nowsec() - lastCycleAt) >= pause

            if hp < heal_min.Value and (not healBusy) and canStart then
                runHealCycle()
            end

            local dt = heal_tick.Value; if dt <= 0 then dt = 0.01 end
            task.wait(dt)
        else
            task.wait(0.10)
        end
    end
end)

heal_toggle:OnChanged(function(v)
    if v and heal_hb.Value then startHB() else stopHB() end
end)
heal_hb:OnChanged(function(v)
    if heal_toggle.Value then if v then startHB() else stopHB() end end
end)
-- ========= [ /TAB: Heal ] =========

-- ========= [ TAB: God Trap — per-structure hotkeys + mouse aim + auto (PERSISTENT BINDS) ] =========
local PlayersGT = game:GetService("Players")
local UIS_GT    = game:GetService("UserInputService")
local LP_GT     = PlayersGT.LocalPlayer
local Mouse     = LP_GT:GetMouse()

Tabs.GodTrap = Tabs.GodTrap or Window:AddTab({ Title = "God Trap", Icon = "shield" })

-- ===== Глобальные настройки ловушки
local gt_only_full     = Tabs.GodTrap:CreateToggle("gt_onlyfull", { Title = "Only FULL God set (3/3)", Default = true })
local gt_only_alive    = Tabs.GodTrap:CreateToggle("gt_alive",    { Title = "Only alive humanoids",   Default = true })
local gt_range         = Tabs.GodTrap:CreateSlider ("gt_range",   { Title = "Max range (studs)",      Min=10, Max=250, Rounding=0, Default=70 })
local gt_snap          = Tabs.GodTrap:CreateToggle("gt_snap",     { Title = "Snap to ground",         Default = true })
local gt_allow_ground  = Tabs.GodTrap:CreateToggle("gt_allow_ground", { Title = "If no target: place at mouse ground", Default = true })
local gt_lead          = Tabs.GodTrap:CreateSlider ("gt_lead",    { Title = "Lead forward (studs)",   Min=0, Max=12, Rounding=1, Default=1.5 })
local gt_yaw           = Tabs.GodTrap:CreateSlider ("gt_yaw",     { Title = "Yaw (deg)",              Min=0, Max=359, Rounding=0, Default=0 })
local gt_yofs          = Tabs.GodTrap:CreateSlider ("gt_yofs",    { Title = "Height offset (studs)",  Min=-3, Max=8,  Rounding=1, Default=0 })
local gt_debug         = Tabs.GodTrap:CreateToggle("gt_debug",    { Title = "Debug prints (F9)",      Default = false })

Tabs.GodTrap:CreateParagraph("gt_sep", { Title = "Manual hotkeys", Content = "Per-structure toggles & binds" })

-- ===== Пер-структурные бинды
local STRUCTS = {
  { name="Big Ol' Hut", defaultKey=Enum.KeyCode.G, defaultCD=0.15 },
  { name="Iron Wall",   defaultKey=Enum.KeyCode.H, defaultCD=0.15 },
  { name="God Hut",     defaultKey=Enum.KeyCode.J, defaultCD=0.15 },
  { name="Ladder",      defaultKey=Enum.KeyCode.K, defaultCD=0.15 },
  { name="Chest",       defaultKey=Enum.KeyCode.L, defaultCD=0.15 },
}

-- Состояние + UI-строки
local S, ROW = {}, {}
for _, it in ipairs(STRUCTS) do
  S[it.name] = { enabled = (it.name=="Big Ol' Hut"), key = it.defaultKey, cd = it.defaultCD, lastAt = 0 }
end

-- helper: парсим название клавиши в Enum.KeyCode
if not _parseKeyName then
    function _parseKeyName(s)
        s = tostring(s or ""):gsub("%s+", "")
        return Enum.KeyCode[s] or Enum.KeyCode.Unknown
    end
end

-- Синк из UI (вызывается после загрузки конфига)
function GT_SyncBindsFromUI()
  for name,row in pairs(ROW) do
    local txt = row.keyShow and row.keyShow.Value or nil
    local kc  = _parseKeyName(txt)
    if kc and kc ~= Enum.KeyCode.Unknown then
      S[name].key = kc
    end
  end
end

-- UI-генератор строки для структуры
local awaitingRebindFor = nil
local function mkRow(data)
  local n = data.name
  local box = Tabs.GodTrap:CreateToggle("gt_en_"..n, { Title = string.format("Enable: %s", n), Default = S[n].enabled })
  local keyShow = Tabs.GodTrap:AddInput("gt_key_"..n, { Title = "Key", Default = S[n].key.Name, Numeric = false, Finished = false })
  local cdSld = Tabs.GodTrap:CreateSlider("gt_cd_"..n, { Title = "Cooldown (s)", Min=0.05, Max=0.8, Rounding=2, Default=S[n].cd })
  Tabs.GodTrap:CreateButton({
    Title = "Rebind "..n.." (click, then press key)",
    Callback = function()
      awaitingRebindFor = n
      Library:Notify({ Title="God Trap", Content="Press a key for "..n.." (Esc to cancel)", Duration=3 })
    end
  })

  keyShow:OnChanged(function(v)
    local kc = _parseKeyName(v)
    if kc and kc ~= Enum.KeyCode.Unknown then
      S[n].key = kc
    end
  end)

  box:OnChanged(function(v) S[n].enabled = v end)
  cdSld:OnChanged(function(v) S[n].cd = v end)

  ROW[n] = { keyShow = keyShow, enable = box, cd = cdSld }
end

for _, it in ipairs(STRUCTS) do mkRow(it) end

-- Капчер клавиши для ребинда
UIS_GT.InputBegan:Connect(function(i, gp)
  if gp then return end
  if awaitingRebindFor and i.UserInputType == Enum.UserInputType.Keyboard then
    if i.KeyCode == Enum.KeyCode.Escape then
      awaitingRebindFor = nil
      Library:Notify({ Title="God Trap", Content="Rebind canceled", Duration=2 })
      return
    end
    if i.KeyCode ~= Enum.KeyCode.Unknown then
      S[awaitingRebindFor].key = i.KeyCode
      pcall(function() ROW[awaitingRebindFor].keyShow:SetValue(i.KeyCode.Name) end)
      Library:Notify({ Title="God Trap", Content=("Bound %s to %s"):format(awaitingRebindFor, i.KeyCode.Name), Duration=2 })
      awaitingRebindFor = nil
    end
  end
end)

-- helpers
local function myRootGT()
  local ch = LP_GT.Character
  return ch and ch:FindFirstChild("HumanoidRootPart") or nil
end

local function _countGodPieces(model)
  if type(countGodPieces) == "function" then
    local ok, n = pcall(function() return countGodPieces(model) end)
    if ok and type(n)=="number" then return n end
  end
  local MATCH = {
    halo  = {"God Halo","Halo"},
    chest = {"God Chestplate","Chestplate","God Armor","Armor"},
    legs  = {"God Legs","Legs","Greaves"}
  }
  local function hit(nm, list)
    nm = string.lower(tostring(nm or "")); for _,v in ipairs(list) do if nm:find(string.lower(v),1,true) then return true end end
    return false
  end
  local b = {halo=false, chest=false, legs=false}
  for _,d in ipairs(model:GetDescendants()) do
    local nm=d.Name
    if not b.halo  and hit(nm, MATCH.halo)  then b.halo  = true end
    if not b.chest and hit(nm, MATCH.chest) then b.chest = true end
    if not b.legs  and hit(nm, MATCH.legs)  then b.legs  = true end
  end
  return (b.halo and 1 or 0) + (b.chest and 1 or 0) + (b.legs and 1 or 0)
end

local function modelFromPart(p)
  local par = p
  while par and par ~= workspace do
    if par:IsA("Model") and (par:FindFirstChildOfClass("Humanoid") or par:FindFirstChild("HumanoidRootPart")) then
      return par
    end
    par = par.Parent
  end
  return nil
end

local function inRange(model, maxd)
  local r = myRootGT(); if not r then return false end
  local hrp = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
  if not hrp then return false end
  return ((hrp.Position - r.Position).Magnitude <= maxd), hrp
end

local function snapToGround(pos)
  if not gt_snap.Value then return pos end
  local rp = RaycastParams.new()
  rp.FilterType = Enum.RaycastFilterType.Exclude
  rp.FilterDescendantsInstances = { LP_GT.Character }
  local res = workspace:Raycast(pos + Vector3.new(0,20,0), Vector3.new(0,-250,0), rp)
  return (res and res.Position) and Vector3.new(pos.X, res.Position.Y + 0.1, pos.Z) or pos
end

local function placeStructureAt(buildingName, position, yawDeg)
  if not (packets and packets.PlaceStructure and packets.PlaceStructure.send) then
    if gt_debug.Value then print("[GTrap] packets missing") end
    return false
  end
  local pos = snapToGround(position + Vector3.new(0, gt_yofs.Value, 0))
  local ok = pcall(function()
    packets.PlaceStructure.send{
      buildingName = buildingName,
      yrot = math.floor((yawDeg or 0)+0.5),
      vec  = pos,
      isMobile = false
    }
  end)
  if gt_debug.Value then
    print(("[GTrap] '%s' @ (%.1f, %.1f, %.1f) yaw=%d ok=%s")
      :format(buildingName, pos.X,pos.Y,pos.Z, math.floor((yawDeg or 0)+0.5), tostring(ok)))
  end
  return ok
end

local function tryPlaceOnModel(buildingName, model)
  if not model then return false end
  if gt_only_alive.Value then
    local hum = model:FindFirstChildOfClass("Humanoid")
    if not (hum and hum.Health > 0) then return false end
  end
  local okR, hrp = inRange(model, gt_range.Value); if not (okR and hrp) then return false end
  if gt_only_full.Value and _countGodPieces(model) < 3 then return false end

  local lead = Vector3.zero
  local vel = hrp.AssemblyLinearVelocity
  if vel and vel.Magnitude > 0.1 then lead = vel.Unit * (gt_lead.Value or 0) end
  return placeStructureAt(buildingName, hrp.Position + lead, gt_yaw.Value)
end

local function tryPlaceAtMouseGround(buildingName)
  local hit = Mouse.Hit
  return hit and placeStructureAt(buildingName, hit.Position, gt_yaw.Value) or false
end

-- Manual: обработчик клавиш
UIS_GT.InputBegan:Connect(function(input, gp)
  if gp or input.UserInputType ~= Enum.UserInputType.Keyboard then return end
  for name, st in pairs(S) do
    if st.enabled and input.KeyCode == st.key then
      local now = tick()
      if now - st.lastAt < st.cd then
        if gt_debug.Value then print("[GTrap] cooldown "..name) end
        return
      end
      local mdl = modelFromPart(Mouse.Target)
      local ok  = tryPlaceOnModel(name, mdl)
      if (not ok) and gt_allow_ground.Value then ok = tryPlaceAtMouseGround(name) end
      if ok then st.lastAt = now end
      break
    end
  end
end)

-- Авто-режим
Tabs.GodTrap:CreateParagraph("gt_auto_sep", { Title = "Auto mode", Content = "Nearest God-set target" })
local auto_on    = Tabs.GodTrap:CreateToggle  ("gt_auto_on",    { Title = "Auto place", Default = false })
local auto_build = Tabs.GodTrap:CreateDropdown("gt_auto_build", { Title = "Auto structure",
  Values = (function() local t = {}; for _,it in ipairs(STRUCTS) do t[#t+1] = it.name end; return t end)(),
  Default = "Big Ol' Hut" })
local auto_cd    = Tabs.GodTrap:CreateSlider  ("gt_auto_cd",    { Title = "Auto cooldown (s)", Min=0.10, Max=1.00, Rounding=2, Default=0.25 })

task.spawn(function()
  while true do
    if auto_on.Value then
      local meR = myRootGT()
      if meR then
        local pf = workspace:FindFirstChild("Players")
        local bestHRP, bestD
        if pf then
          for _,m in ipairs(pf:GetChildren()) do
            if m:IsA("Model") and m.Name ~= LP_GT.Name then
              local okR, hrp = inRange(m, gt_range.Value)
              if okR and hrp then
                local alive = true
                if gt_only_alive.Value then
                  local h = m:FindFirstChildOfClass("Humanoid")
                  alive = h and h.Health > 0
                end
                local piecesOK = (not gt_only_full.Value) or _countGodPieces(m) >= 3
                if alive and piecesOK then
                  local d = (hrp.Position - meR.Position).Magnitude
                  if (not bestD) or d < bestD then bestHRP, bestD = hrp, d end
                end
              end
            end
          end
        end
        if bestHRP then
          local lead = Vector3.zero
          local vel = bestHRP.AssemblyLinearVelocity
          if vel and vel.Magnitude > 0.1 then lead = vel.Unit * (gt_lead.Value or 0) end
          placeStructureAt(auto_build.Value or "Big Ol' Hut", bestHRP.Position + lead, gt_yaw.Value)
        end
      end
      task.wait(auto_cd.Value)
    else
      task.wait(0.15)
    end
  end
end)
-- ========= [ /TAB: God Trap ] =========

-- ========= Super Jump (по бинду) =========
local Players   = game:GetService("Players")
local UIS       = game:GetService("UserInputService")
local RunService= game:GetService("RunService")

local LP        = Players.LocalPlayer

-- НАСТРОЙКИ
local SJ_KEY        = Enum.KeyCode.V      -- ключ (измени если надо)
local SJ_HEIGHT     = 30                  -- целевая высота прыжка (в студax)
local SJ_DURATION   = 0.12                -- длительность импульса (сек)
local SJ_COOLDOWN   = 1.0                 -- кд между суперпрыжками (сек)
local SJ_MODE       = "impulse"           -- "impulse" | "jumppower"

-- ===== не трогай ниже =====
local lastSJ = 0
local function getHumanoid()
    local ch = LP.Character or LP.CharacterAdded:Wait()
    return ch:FindFirstChildOfClass("Humanoid"), ch:FindFirstChild("HumanoidRootPart")
end

local function calcVy(height)
    local g = (workspace and workspace.Gravity) or 196.2
    return math.sqrt(math.max(0, 2 * g * height))
end

local function impulseY(root, vy, dur)
    local bv = Instance.new("BodyVelocity")
    bv.Name = "_SUPERJUMP"
    bv.MaxForce = Vector3.new(0, 1e9, 0)
    local cur = root.AssemblyLinearVelocity or Vector3.zero
    bv.Velocity = Vector3.new(cur.X, vy, cur.Z)
    bv.Parent = root
    task.delay(math.max(0.02, dur or 0.1), function()
        pcall(function() bv:Destroy() end)
    end)
end

local function superJump()
    local now = tick()
    if now - lastSJ < SJ_COOLDOWN then return end
    lastSJ = now

    local hum, root = getHumanoid()
    if not (hum and root and hum.Health > 0) then return end

    local vy = calcVy(SJ_HEIGHT)

    -- заставим Humanoid реально прыгнуть
    pcall(function()
        hum.Jump = true
        hum:ChangeState(Enum.HumanoidStateType.Jumping)
    end)

    if SJ_MODE == "jumppower" then
        -- временно поднимаем JumpPower / JumpHeight
        local oldJP, oldJH, usedJP
        pcall(function()
            if hum.UseJumpPower ~= false and hum.JumpPower ~= nil then
                oldJP, usedJP = hum.JumpPower, true
                hum.JumpPower = vy
            else
                oldJH, usedJP = hum.JumpHeight, false
                hum.JumpHeight = SJ_HEIGHT
            end
        end)
        task.delay(0.25, function()
            pcall(function()
                if usedJP and oldJP then hum.JumpPower = oldJP
                elseif (not usedJP) and oldJH then hum.JumpHeight = oldJH end
            end)
        end)
    else
        -- импульс по Y через BodyVelocity (рекомендуется)
        impulseY(root, vy, SJ_DURATION)
    end
end

-- биндим клавишу
UIS.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == SJ_KEY then
        superJump()
    end
end)

-- опционально: функции для быстрой смены настроек из консоли
getgenv()._SetSuperJumpKey = function(name)  -- пример: _SetSuperJumpKey("B")
    local kc = Enum.KeyCode[name] or Enum.KeyCode.Unknown
    if kc ~= Enum.KeyCode.Unknown then SJ_KEY = kc; print("[SJ] key =", name) end
end
getgenv()._SetSuperJumpHeight = function(h)   -- пример: _SetSuperJumpHeight(40)
    SJ_HEIGHT = tonumber(h) or SJ_HEIGHT; print("[SJ] height =", SJ_HEIGHT)
end
getgenv()._SetSuperJumpMode = function(mode)  -- "impulse" или "jumppower"
    if mode == "impulse" or mode == "jumppower" then SJ_MODE = mode; print("[SJ] mode =", mode) end
end

print("[SJ] Super Jump загружен. Нажми "..SJ_KEY.Name.." для большого прыжка.")


-- ========= [ Finish / Autoload ] =========
Window:SelectTab(1)
Library:Notify{ Title="Fuger Hub", Content="Loaded: Configs + Loot + Combat (x2 burst) + ESP + Heal + GodTrap", Duration=6 }

pcall(function()
    SaveManager:LoadAutoloadConfig()
end)

-- после автолоада — подтянем реальные переменные из UI (Follow key, GodTrap binds и т.п.)
pcall(function()
    if typeof(SyncRuntimeFromUI) == "function" then
        SyncRuntimeFromUI()
    end
end)

pcall(function()
    local ok = Route_LoadFromFile(ROUTE_AUTOSAVE, _G.__ROUTE, _G.__ROUTE._redraw)
    if ok then Library:Notify{ Title="Route", Content="Route autosave loaded", Duration=3 } end
end)
