-- Fuger Hub — Booga Booga Reborn (FULL, без Speed-Fly по твоему запросу)
-- UI: Fluent-Renewed  •  Автор: Fuger XD

-- ========= [ Fluent UI и менеджеры ] =========
local Library = loadstring(game:HttpGetAsync("https://github.com/1dontgiveaf/Fluent-Renewed/releases/download/v1.0/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/1dontgiveaf/Fluent-Renewed/refs/heads/main/Addons/SaveManager.luau"))()
local InterfaceManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/1dontgiveaf/Fluent-Renewed/refs/heads/main/Addons/InterfaceManager.luau"))()

-- ========= [ Services / utils ] =========
local HttpService       = game:GetService("HttpService")
local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService        = game:GetService("RunService")
local Workspace         = game:GetService("Workspace")
local UIS               = game:GetService("UserInputService")
local Lighting          = game:GetService("Lighting")

local plr  = Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local hum  = char:WaitForChild("Humanoid")
local root = char:WaitForChild("HumanoidRootPart")

local function ensureChar()
    char = plr.Character or plr.CharacterAdded:Wait()
    hum  = char:WaitForChild("Humanoid")
    root = char:WaitForChild("HumanoidRootPart")
end
plr.CharacterAdded:Connect(function() task.defer(ensureChar) end)

-- ==== Friend cache (Roblox friends) ====
local Friend = { set = {}, last = 0, ttl = 60 }

local function refreshFriends(force)
    if not force and (tick() - Friend.last) < Friend.ttl then return end
    Friend.last = tick()
    local ok, pages = pcall(function()
        return Players:GetFriendsAsync(plr.UserId)
    end)
    if not ok or not pages then return end
    local set = {}
    while true do
        for _, f in ipairs(pages:GetCurrentPage()) do
            set[f.Id] = true
        end
        if pages.IsFinished then break end
        pcall(function() pages:AdvanceToNextPageAsync() end)
    end
    Friend.set = set
end
refreshFriends(true)
task.spawn(function()
    while true do
        refreshFriends(false)
        task.wait(30)
    end
end)

local function isFriendPlayer(p)
    if not p or not p.UserId then return false end
    if Friend.set[p.UserId] then return true end
    local ok, v = pcall(function() return plr:IsFriendsWith(p.UserId) end)
    if ok and v then Friend.set[p.UserId] = true; return true end
    return false
end

local function isFriendByModelName(modelName)
    local p = Players:FindFirstChild(modelName)
    return isFriendPlayer(p)
end

-- ========= [ Packets (без ошибок, если модуля нет) ] =========
local packets do
    local ok, mod = pcall(function() return require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Packets")) end)
    packets = ok and mod or {}
end
local function swingtool(eids)
    if type(eids) ~= "table" then eids = { eids } end
    if packets and packets.SwingTool and packets.SwingTool.send then
        pcall(function() packets.SwingTool.send(eids) end)
    end
end
local function pickup(eid)
    if packets and packets.Pickup and packets.Pickup.send then
        pcall(function() packets.Pickup.send(eid) end)
    end
end

-- ========= [ Window / Tabs ] =========
local Window = Library:CreateWindow{
    Title = "Fuger Hub -- Booga Booga Reborn",
    SubTitle = "by Fuger XD",
    Size = UDim2.fromOffset(900, 600),
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
}
local Tabs = {}
Tabs.Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })

-- менеджеры
SaveManager:SetLibrary(Library)
InterfaceManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

-- ========= [ Helpers ] =========
local function sanitize(name)
    name = tostring(name or ""):gsub("[%c\\/:*?\"<>|]+",""):gsub("^%s+",""):gsub("%s+$","")
    return name == "" and "default" or name
end

-- ========= [ ROUTE persist ] =========
local function routePath(cfg) return "FluentScriptHub/specific-game/"..sanitize(cfg)..".route.json" end
local ROUTE_AUTOSAVE = "FluentScriptHub/specific-game/_route_autosave.json"

local function encodeRoute(points)
    local t = {}
    for i,p in ipairs(points or {}) do
        t[i] = { x=p.pos.X, y=p.pos.Y, z=p.pos.Z, wait=p.wait or 0, js=p.jump_start or nil, je=p.jump_end or nil }
    end
    return t
end
local function decodeRoute(t)
    local out = {}
    for _,r in ipairs(t or {}) do
        table.insert(out, { pos=Vector3.new(r.x,r.y,r.z), wait=(r.wait and r.wait>0) and r.wait or nil, jump_start=r.js or nil, jump_end=r.je or nil })
    end
    return out
end
local function Route_SaveToFile(path, points)
    if not writefile then return false end
    local ok, json = pcall(function() return HttpService:JSONEncode(encodeRoute(points)) end)
    if not ok then return false end
    local ok2 = pcall(writefile, path, json)
    return ok2 == true or ok2 == nil
end
local function Route_LoadFromFile(path, Route, redraw)
    if not (isfile and readfile) or not isfile(path) then return false end
    local ok, json = pcall(readfile, path); if not ok then return false end
    local ok2, arr = pcall(function() return HttpService:JSONDecode(json) end); if not ok2 then return false end
    table.clear(Route.points)
    if redraw and type(redraw.clearDots) == "function" then redraw.clearDots() end
    for _,p in ipairs(decodeRoute(arr)) do
        table.insert(Route.points, p)
        if redraw and type(redraw.dot) == "function" then redraw.dot(Color3.fromRGB(255,230,80), p.pos, 0.7) end
    end
    return true
end

-- ========= [ Общие инвентарь/еды ] =========
function findInventoryList()
    local pg = plr:FindFirstChild("PlayerGui"); if not pg then return nil end
    local mg = pg:FindFirstChild("MainGui");    if not mg then return nil end
    local rp = mg:FindFirstChild("RightPanel"); if not rp then return nil end
    local inv = rp:FindFirstChild("Inventory"); if not inv then return nil end
    return inv:FindFirstChild("List")
end
function getSlotByName(itemName)
    local list = findInventoryList()
    if not list then return nil end
    for _,child in ipairs(list:GetChildren()) do
        if child:IsA("ImageLabel") and child.Name == itemName then
            return child.LayoutOrder
        end
    end
    return nil
end
function consumeBySlot(slot)
    if not slot then return false end
    if packets and packets.UseBagItem     and packets.UseBagItem.send     then pcall(function() packets.UseBagItem.send(slot) end);     return true end
    if packets and packets.ConsumeBagItem and packets.ConsumeBagItem.send then pcall(function() packets.ConsumeBagItem.send(slot) end); return true end
    if packets and packets.ConsumeItem    and packets.ConsumeItem.send    then pcall(function() packets.ConsumeItem.send(slot) end);    return true end
    if packets and packets.UseItem        and packets.UseItem.send        then pcall(function() packets.UseItem.send(slot) end);        return true end
    return false
end
_G.fruittoitemid = _G.fruittoitemid or {
    Bloodfruit=94, Bluefruit=377, Lemon=99, Coconut=1, Jelly=604, Banana=606, Orange=602,
    Oddberry=32, Berry=35, Strangefruit=302, Strawberry=282, Sunfruit=128, Pumpkin=80,
    ["Prickly Pear"]=378, Apple=243, Barley=247, Cloudberry=101, Carrot=147
}
function getItemIdByName(name) local t=_G.fruittoitemid return t and t[name] or nil end
function consumeById(id)
    if not id then return false end
    if packets and packets.ConsumeItem and packets.ConsumeItem.send then pcall(function() packets.ConsumeItem.send(id) end); return true end
    if packets and packets.UseItem     and packets.UseItem.send     then pcall(function() packets.UseItem.send({itemID=id}) end); return true end
    if packets and packets.Eat         and packets.Eat.send         then pcall(function() packets.Eat.send(id) end); return true end
    if packets and packets.EatFood     and packets.EatFood.send     then pcall(function() packets.EatFood.send(id) end); return true end
    return false
end

-- ========= [ TAB: Configs ] =========
Tabs.Configs = Window:AddTab({ Title = "Configs", Icon = "save" })

-- общий парсер клавиш (если уже есть в коде — не переопределим)
if not _parseKeyName then
    function _parseKeyName(s)
        s = tostring(s or ""):gsub("%s+", "")
        return Enum.KeyCode[s] or Enum.KeyCode.Unknown
    end
end

-- === Runtime sync из UI после загрузки конфига ===
local function SyncRuntimeFromUI()
    -- FOLLOW: восстановить реальный KeyCode из инпута
    if follow_key_label then
        local ok, txt = pcall(function() return follow_key_label.Value end)
        if ok then
            local kc = _parseKeyName(txt)
            if kc ~= Enum.KeyCode.Unknown then
                _followKey = kc
            end
        end
    end
    -- GOD TRAP: если есть функция синка — вызовем
    if type(GT_SyncBindsFromUI) == "function" then
        pcall(GT_SyncBindsFromUI)
    end
end

local cfgName = "default"
local cfgInput = Tabs.Configs:AddInput("cfg_name_input",{ Title="Config name", Default=cfgName })
cfgInput:OnChanged(function(v) cfgName = sanitize(v) end)
Tabs.Configs:CreateButton({
    Title="Quick Save",
    Callback=function()
        local n = sanitize(cfgName)
        pcall(function() SaveManager:Save(n) end)
        Route_SaveToFile(routePath(n), (_G.__ROUTE and _G.__ROUTE.points) or {})
        Route_SaveToFile(ROUTE_AUTOSAVE, (_G.__ROUTE and _G.__ROUTE.points) or {})
        Library:Notify{ Title="Configs", Content="Saved "..n.." (+route)", Duration=3 }
    end
})
Tabs.Configs:CreateButton({
    Title="Quick Load",
    Callback=function()
        local n = sanitize(cfgName)
        pcall(function() SaveManager:Load(n) end)
        if _G.__ROUTE then
            local ok = Route_LoadFromFile(routePath(n), _G.__ROUTE, _G.__ROUTE._redraw)
            Library:Notify{ Title="Configs", Content="Loaded "..n..(ok and " +route" or " (no route file)"), Duration=3 }
        else
            Library:Notify{ Title="Configs", Content="Loaded "..n, Duration=3 }
        end
        SyncRuntimeFromUI() -- ← применяем реальные переменные из UI
    end
})
local auto = Tabs.Configs:CreateToggle("autoload_cfg",{ Title="Autoload this config", Default=true })
auto:OnChanged(function(v)
    local n = sanitize(cfgName)
    if v then pcall(function() SaveManager:SaveAutoloadConfig(n) end)
    else pcall(function() SaveManager:DeleteAutoloadConfig() end) end
end)

-- ========= [ TAB: Auto Loot ] =========
Tabs.Loot = Window:AddTab({ Title = "Auto Loot", Icon = "package" })
local LOOT_ITEM_NAMES = {
    "Berry","Bloodfruit","Bluefruit","Lemon","Strawberry","Gold","Raw Gold","Crystal Chunk",
    "Coin","Coins","Coin Stack","Essence","Emerald","Raw Emerald","Pink Diamond",
    "Raw Pink Diamond","Void Shard","Jelly","Magnetite","Raw Magnetite","Adurite","Raw Adurite",
    "Ice Cube","Stone","Iron","Raw Iron","Steel","Hide","Leaves","Log","Wood","Pie"
}
local loot_on        = Tabs.Loot:CreateToggle("loot_on",      { Title="Auto Loot", Default=false })
local loot_range     = Tabs.Loot:CreateSlider("loot_range",   { Title="Range (studs)", Min=5, Max=150, Rounding=0, Default=40 })
local loot_batch     = Tabs.Loot:CreateSlider("loot_batch",   { Title="Max pickups / tick", Min=1, Max=50, Rounding=0, Default=12 })
local loot_cd        = Tabs.Loot:CreateSlider("loot_cd",      { Title="Tick cooldown (s)", Min=0.03, Max=0.4, Rounding=2, Default=0.08 })
local loot_chests    = Tabs.Loot:CreateToggle("loot_chests",  { Title="Also loot chests (Contents)", Default=true })
local loot_blacklist = Tabs.Loot:CreateToggle("loot_black",   { Title="Use selection as Blacklist (else Whitelist)", Default=false })
local loot_debug     = Tabs.Loot:CreateToggle("loot_debug",   { Title="Debug (F9)", Default=false })
local loot_dropdown  = Tabs.Loot:CreateDropdown("loot_items", { Title="Items (multi)", Values = LOOT_ITEM_NAMES, Multi=true, Default = { Leaves = true, Log = true } })

local function safePickup2(eid)
    local ok = pcall(function() pickup(eid) end)
    if not ok and packets and packets.Pickup and packets.Pickup.send then
        pcall(function() packets.Pickup.send(eid) end)
    end
end
local DROP_FOLDERS = { "Items","Drops","WorldDrops","Loot","Dropped","Resources" }
local watchedFolders, conns = {}, {}
local cache = {}
local function normalizedName(inst)
    local a
    if inst.GetAttribute then
        a = inst:GetAttribute("ItemName") or inst:GetAttribute("Name") or inst:GetAttribute("DisplayName")
    end
    if typeof(a) == "string" and a ~= "" then return a end
    return inst.Name
end
local function addDrop(inst)
    if cache[inst] then return end
    local eid = inst.GetAttribute and inst:GetAttribute("EntityID")
    if not eid then return end
    local name = normalizedName(inst)
    local getPos
    if inst:IsA("Model") then
        local pp = inst.PrimaryPart or inst:FindFirstChildWhichIsA("BasePart"); if not pp then return end
        getPos = function() return pp.Position end
    elseif inst:IsA("BasePart") or inst:IsA("MeshPart") then
        getPos = function() return inst.Position end
    else
        return
    end
    cache[inst] = { eid = eid, name = name, getPos = getPos }
end
local function removeDrop(inst) cache[inst] = nil end
local function hookFolder(folder)
    if not folder or watchedFolders[folder] then return end
    watchedFolders[folder] = true
    for _,ch in ipairs(folder:GetChildren()) do addDrop(ch) end
    conns[#conns+1] = folder.ChildAdded:Connect(addDrop)
    conns[#conns+1] = folder.ChildRemoved:Connect(removeDrop)
end
local function hookChests()
    local dep = workspace:FindFirstChild("Deployables")
    if not dep then return end
    for _,mdl in ipairs(dep:GetChildren()) do
        if mdl:IsA("Model") then
            local contents = mdl:FindFirstChild("Contents")
            if contents and not watchedFolders[contents] then
                hookFolder(contents)
            end
        end
    end
    conns[#conns+1] = dep.ChildAdded:Connect(function(mdl)
        task.defer(function()
            if mdl:IsA("Model") then
                local contents = mdl:FindFirstChild("Contents")
                if contents then hookFolder(contents) end
            end
        end)
    end)
end
for _,n in ipairs(DROP_FOLDERS) do hookFolder(workspace:FindFirstChild(n)) end
hookChests()
task.spawn(function()
    while true do
        for _,n in ipairs(DROP_FOLDERS) do
            local f = workspace:FindFirstChild(n)
            if f and not watchedFolders[f] then hookFolder(f) end
        end
        if loot_chests.Value then hookChests() end
        task.wait(1.0)
    end
end)
local function selectedSet()
    local sel, val = {}, loot_dropdown.Value
    if typeof(val) == "table" then
        for k,v in pairs(val) do if v then sel[string.lower(k)] = true end end
    end
    return sel
end
task.spawn(function()
    while true do
        if loot_on.Value and root then
            local set       = selectedSet()
            local useBlack  = loot_blacklist.Value
            local range     = loot_range.Value
            local maxPer    = math.max(1, math.floor(loot_batch.Value))
            local candidates = {}
            for inst,info in pairs(cache) do
                if inst.Parent then
                    local isContents = false
                    if not loot_chests.Value then
                        local p = inst.Parent
                        while p and p ~= workspace do
                            if p.Name == "Contents" then isContents = true; break end
                            p = p.Parent
                        end
                    end
                    if not isContents then
                        local pos = info.getPos()
                        local d   = (pos - root.Position).Magnitude
                        if d <= range then
                            local nm   = info.name or "Unknown"
                            local pass = true
                            if next(set) ~= nil then
                                local inSel = set[string.lower(nm)] == true
                                pass = (useBlack and (not inSel)) or ((not useBlack) and inSel)
                            end
                            if pass then candidates[#candidates+1] = { eid = info.eid, dist = d, name = nm } end
                        end
                    end
                end
            end
            if #candidates > 1 then table.sort(candidates, function(a,b) return a.dist < b.dist end) end
            if loot_debug.Value then
                print(("[AutoLoot] candidates=%d (mode=%s, chests=%s)")
                    :format(#candidates, useBlack and "Blacklist" or "Whitelist", tostring(loot_chests.Value)))
            end
            for i = 1, math.min(maxPer, #candidates) do
                safePickup2(candidates[i].eid)
                if loot_debug.Value then
                    print(("[AutoLoot] pickup #%d: %s [%.1f]"):format(i, candidates[i].name, candidates[i].dist))
                end
                task.wait(0.01)
            end
            task.wait(loot_cd.Value)
        else
            task.wait(0.15)
        end
    end
end)
-- ===================== /TAB: Combat =====================

local HealTab = Window:AddTab({ Title = "Heal", Icon = "heart" })

local heal_toggle = HealTab:CreateToggle("heal_auto", { Title = "Auto Heal", Default = false })
local heal_item   = HealTab:CreateDropdown("heal_item", {
    Title  = "Item to use",
    Values = { "Bloodfruit","Bluefruit","Berry","Strawberry","Coconut","Apple","Lemon","Orange","Banana" },
    Default = "Bloodfruit"
})

local heal_min = HealTab:CreateSlider("heal_min", { Title = "Heal when HP below (%)", Min = 1, Max = 99, Rounding = 0, Default = 70 })
local heal_max = HealTab:CreateSlider("heal_max", { Title = "Stop when HP reaches (%)", Min = 2, Max = 100, Rounding = 0, Default = 90 })

local heal_hb   = HealTab:CreateToggle("heal_hb", { Title = "Use Heartbeat pacing", Default = true })
local heal_cd   = HealTab:CreateSlider("heal_cd", { Title = "Per-bite delay (s)", Min = 0.00, Max = 0.30, Rounding = 2, Default = 0.02 })
local heal_tick = HealTab:CreateSlider("heal_tick",{ Title = "Check interval (s) [timer mode]", Min = 0.00, Max = 0.20, Rounding = 2, Default = 0.01 })


local function readHPpct()
    if hum == nil or hum.MaxHealth == 0 then return 100 end
    local v = (hum.Health / hum.MaxHealth) * 100
    return math.clamp(v, 0, 100)
end

local function clampBand()
    if heal_min.Value >= heal_max.Value then
        if heal_max.Value < 100 then heal_min:SetValue(heal_max.Value - 1) else heal_min:SetValue(99) end
    end
end
heal_min:OnChanged(clampBand)
heal_max:OnChanged(clampBand)

local function nowsec()
    return (typeof(time)=="function" and time()) or os.clock()
end

local function biteOnce(it)
    local slot = getSlotByName(it)
    return (slot ~= nil and consumeBySlot(slot)) or consumeById(getItemIdByName(it))
end

local lastCycleAt = 0
local healBusy    = false

local function runHealCycle()
    healBusy = true
    local it = heal_item.Value or "Bloodfruit"
    local target = math.clamp(heal_max.Value, heal_min.Value + 1, 100)
    local maxBites = 120
    local totalBites = 0

    if heal_debug.Value then
        print(string.format("[AutoHeal] start cycle: hp=%.1f -> target=%.1f (pause %.2fs, overdrive=%s, burst=%d)",
            readHPpct(), target, (heal_cycle_pause.Value or 3), tostring(heal_overdrive.Value), heal_burst.Value))
    end

    while readHPpct() < target and maxBites > 0 do
        local burst = (heal_overdrive.Value and math.max(1, math.floor(heal_burst.Value))) or 1

        for j = 1, burst do
            if readHPpct() >= target or maxBites <= 0 then break end
            local used = biteOnce(it)
            totalBites += 1
            maxBites   -= 1
            if heal_debug.Value then print("[AutoHeal] bite ->", used) end

            if heal_overdrive.Value then
                local n = math.max(1, math.floor(heal_yield_n.Value))
                if (totalBites % n) == 0 then task.wait() end
            end
        end

        if not heal_overdrive.Value then
            local d = heal_cd.Value; if d < 0 then d = 0 end
            if d > 0 then task.wait(d) else task.wait() end
        else
            local d = heal_cd.Value; if d < 0 then d = 0 end
            if d > 0 then task.wait(d) end
        end
    end

    lastCycleAt = nowsec()
    healBusy = false
    if heal_debug.Value then
        print(string.format("[AutoHeal] cycle done (bites=%d); pause until %.2f", totalBites, lastCycleAt + (heal_cycle_pause.Value or 3)))
    end
end

local hbConn
local function stopHB() if hbConn then hbConn:Disconnect(); hbConn = nil end end

local function startHB()
    stopHB()
    hbConn = RunService.Heartbeat:Connect(function()
        if not heal_toggle.Value or not hum or not hum.Parent then return end

        local hp = readHPpct()
        local pause = heal_cycle_pause.Value or 3
        local canStart = (nowsec() - lastCycleAt) >= pause

        if hp < heal_min.Value and (not healBusy) and canStart then
            task.spawn(runHealCycle)
        end
    end)
end

task.spawn(function()
    while true do
        if heal_toggle.Value and hum and hum.Parent and not heal_hb.Value then
            local hp = readHPpct()
            local pause = heal_cycle_pause.Value or 3
            local canStart = (nowsec() - lastCycleAt) >= pause

            if hp < heal_min.Value and (not healBusy) and canStart then
                runHealCycle()
            end

            local dt = heal_tick.Value; if dt <= 0 then dt = 0.01 end
            task.wait(dt)
        else
            task.wait(0.10)
        end
    end
end)

heal_toggle:OnChanged(function(v)
    if v and heal_hb.Value then startHB() else stopHB() end
end)
heal_hb:OnChanged(function(v)
    if heal_toggle.Value then if v then startHB() else stopHB() end end
end)
-- ========= [ /TAB: Heal ] =========

-- ========= [ Finish / Autoload ] =========
Window:SelectTab(1)
Library:Notify{ Title="Fuger Hub", Content="Loaded: Configs + Loot + Combat (x2 burst) + ESP + Heal + GodTrap", Duration=6 }

pcall(function()
    SaveManager:LoadAutoloadConfig()
end)

-- после автолоада — подтянем реальные переменные из UI (Follow key, GodTrap binds и т.п.)
pcall(function()
    if typeof(SyncRuntimeFromUI) == "function" then
        SyncRuntimeFromUI()
    end
end)

pcall(function()
    local ok = Route_LoadFromFile(ROUTE_AUTOSAVE, _G.__ROUTE, _G.__ROUTE._redraw)
    if ok then Library:Notify{ Title="Route", Content="Route autosave loaded", Duration=3 } end
end)
